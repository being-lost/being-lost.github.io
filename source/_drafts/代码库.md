---
title: 代码库
categories:
  - null
date: 2023-06-26 08:44:35
tags:
---

hello world

---

[toc]

##### 让spring mvc支持body中传单个参数

```java
//这样是无法接收到参数的，必须要写一个对象把name包起来
public void test(@RequestBody String name){}
```

所以自定义一个`Converter`，来支持这种写法（所以为什么不用`get`。。）

```java
import org.springframework.http.HttpInputMessage;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.http.converter.json.MappingJackson2HttpMessageConverter;

import java.io.IOException;
import java.lang.reflect.Type;
import java.util.LinkedHashMap;

public class ConvertBodySingleJsonParam extends MappingJackson2HttpMessageConverter {

    @Override
    public Object read(Type type, Class<?> contextClass, HttpInputMessage inputMessage)
            throws IOException, HttpMessageNotReadableException {
        Type deseriType = getType(type);
        Object param = super.read(deseriType, contextClass, inputMessage);
        return getTrueObject(type, param);
    }

    private Type getType(Type type) {
        Type deseriClazz;
        if (supportType(type)) {
            //jackson不支持String默认用LinkedHashMap
            deseriClazz = LinkedHashMap.class;
        } else {
            deseriClazz = type;
        }
        return deseriClazz;
    }

    private Object getTrueObject(Type type, Object param) {
        if (supportType(type)) {
            Object backParam = null;
            if (param instanceof LinkedHashMap) {
                LinkedHashMap paramMap = (LinkedHashMap) param;
                if (paramMap.size() == 1) {
                    //如果是string，传给jackson的就是LinkedMap
                    //这里似乎拿不到接口的实体，无法获取参数名，所以只取一个
                    backParam = paramMap.get(paramMap.keySet().iterator().next());
                }
            }
            param = handlerResult(type, backParam);
        }
        return param;
    }
    //可以添加支持的类型
    private boolean supportType(Type type) {
        if (
                type == Long.class
                        || type == String.class
                        || type == Integer.class
        ) {
            return true;
        }
        return false;
    }
    private Object handlerResult(Type type, Object backParam) {
        if (type == Long.class) {
            return Long.valueOf(backParam.toString());
        }
        return backParam;
    }
    //这个方法实际上没有用，父类中也没有被调用过
    @Override
    protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {
        Class<?> deseriClazz = getClazz(clazz);
        Object param = super.readInternal(deseriClazz, inputMessage);
        return getTrueObject(clazz, param);
    }

    private Class<?> getClazz(Class<?> clazz) {
        Class<?> deseriClazz;
        if (clazz == Long.class) {
            //jackson不支持String默认用LinkedHashMap
            deseriClazz = LinkedHashMap.class;
        } else {
            deseriClazz = clazz;
        }
        return deseriClazz;
    }
}
```

添加到`ConverterList`中

```java
@Configuration
public class ConfigWeb implements WebMvcConfigurer {
    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //实际调用时，会遍历所有converter，由于spring内置了很多converter
        //而且string类型会被其他converter处理，所以这里index设置为0，放在最前面
        converters.add(0, new ConvertBodySingleJsonParam());
    }
}
```

