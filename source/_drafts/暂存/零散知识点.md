### base64

#### 介绍

StackOverflow的问题：What is base 64 encoding used for？

https://stackoverflow.com/questions/201479/what-is-base-64-encoding-used-for



简单描述：

传输一些二进制数据时，因为一些原因导致收到的数据不完整，

所以将二进制数据按照某种**编码格式**，转换成文本来传输，来**确保数据完整**。

base64只是其中一种编码格式。





### update中set的隔离性

> sqlserver中

name的判断条件中，age还是**更新前**的数据

```sql
update user
set
	age = age + 10,
	name = iif( age > 10 , 'y' , 'n' )	
```









### NoClassDefFoundError

#### 一：springUtil.getProperty()

```

```



### mybatis查询后，字段类型对不上，导致注入失败

缺少无参构造器

class中没有构造器时，会自动生成一个默认的无参构造器

一旦自己写了一个构造器，那么会覆盖掉无参

于是mybatis用了自己写的构造器，导致对不上

所以，普通类随手加上无参构造器，是个好习惯



### sqlserver大小写问题

##### COLLATE排序规则可设置大小写是否敏感

- CI：case-insensitive

- CS：case-sensitive

##### 排序规则的作用范围有：

- 指定数据库：所有的字段名、字段值
- 指定单个字段：只针对字段值

##### 不同规则的值不能比较大小

以下sql都会报错

```sql
select * from user where name_ci = name_sc

select * from user a 
join user b on a.name_ci = b.name_cs
```

但是可以临时设置字符集，在字段后面加上 `collate <字符集>`

```sql
select * from user a 
join user b on a.name_ci = b.name_cs collate Chinese_PRC_CI_AI 
```



#### mapstruct

依赖，见官网

```xml
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct</artifactId>
    <version>1.5.2.Final</version>
</dependency>
<dependency>
    <groupId>org.mapstruct</groupId>
    <artifactId>mapstruct-processor</artifactId>
    <version>1.5.2.Final</version>
</dependency>
```

##### 使用

```java
@Mapper
public interface PersonMapper {
    PersonMapper INSTANCT = Mappers.getMapper(PersonMapper.class);
	

	@Mapping(target = "name", source = "personName")
	@Mapping(target = "id", ignore = true) // 忽略id，不进行映射
    PersonDTO conver(Person person);

}
```



### 二进制计算

2的n次方相加

n = 

- 从右往左，1的偏移量
- 1的下标
- 1的右边有几个位

```
01 = 2**0
10 = 2**1
100 = 2**2
1000 = 2**3 

10110 =	2**4 + 2**2 + 2**1 = 16+4+2 = 22
```



### 泛型

本质：把数据类型抽取，参数化

##### 抽取数据的值

```java
int type = 1;
int type = 2;

private int type;
```

##### 抽取数据的类型

```java
public void add(String e){}
public void add(Integer e){}

public void add(E e){}
```

java程序执行的过程：

源码.java——编译器——》》字节码.class——虚拟机——》》内存中运行

泛型编译成字节码的时候，实际上还是object，而且`ArrayList<T>`内部的也是`object[]`。

也叫做，**泛型擦去**。

所以泛型的写法，**实际上是编译器实现的**。

编译器允许这种泛型的写法，并且保存数据类型，自动进行类型转换，**所以也得益于多态**

> 所以 `int` 和 `Integer`的自动装箱、拆箱，应该也是编译器帮忙

```java
String value = (String) list.get(0);
```



---

### 枚举和接口

#### 枚举的特性

##### 枚举元素独有的方法无法被外界访问

并且内部不能用static方法

```java
public Enum Color{
	red{       
		public void inside(){}
        public static void inside2(){} //无法使用static，无法通过编译
	};
    
    public void outside(){}
    public static void outside(){}
}

Color.red.outside();
Color.outside2();
Color.red.inside();//外界无法访问
```

所以枚举相当于一个严格的**接口——实现**的方式

### 注解annotation

##### 基础使用

```java
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation{
    String value();
}
```

#### 元注解

java定义了4个，先解释上面用到的两个，**也是最常用的**

##### @Target

表示该注解可以加到代码什么位置

```
ElementType
	1.CONSTRUCTOR:用于描述构造器
    2.FIELD:用于描述域
    3.LOCAL_VARIABLE:用于描述局部变量
    4.METHOD:用于描述方法
    5.PACKAGE:用于描述包
    6.PARAMETER:用于描述参数
    7.TYPE:用于描述类、接口(包括注解类型) 或enum声明
```

##### @Retention

表示该注解的存活时间

```
RetentionPolicy	
	1.SOURCE:在源文件中有效（即源文件保留）
    2.CLASS:在class文件中有效（即class保留）
    3.RUNTIME:在运行时有效（即运行时保留）
```

只有RUNTIME，才能使用反射获取注解的信息

##### @Documented

用于生成文档，**没啥用**

##### @Inherited

该注解加在类上（所以需要搭配@Target），这个类的子类也会继承该注解。

如果加在接口上，子接口则不会继承，但是子类会继承。

**没啥用**

#### 注解中的方法返回值类型

1. 所有基本数据类型（int,float,boolean,byte,double,char,long,short)
2. String类型
3. Class类型
4. enum类型
5. Annotation类型
6. 以上所有类型的数组

##### 可以使用默认值

```java
String value() default "hello" ;
```









### 对称加密

双方持有**同一个密钥**，加密、解密使用同一个密钥

### 非对称加密

参考：https://www.cnblogs.com/pcheng/p/9629621.html

有公钥、私钥，组成一对，加密、解密使用不同密钥

##### 加密和签名

用公钥加密，**叫加密**：防止信息被破解，导致泄露

用私钥加密，**叫签名**：防止信息被篡改

##### 举例

A==>B发送信息











### queue接口

```
boolean add(E e);
boolean offer(E e);
E remove();
E poll();
E element();
E peek();
```

获取队列第一个，但是不删除

```java
E element();//唯一区别，队列为空，会报错
E peek();//队列为空，返回null
```





### 必应的单词翻译接口

https://cn.bing.com/dict/SerpHoverTrans?q=hello





### idea中debug

断点variables中，可以实时右键 `set value` 修改变量值





### 服务间调用

rpc



### 多线程

futureTask

callback异步回调



### 两个事务操作同一个id，A事务先insert，B事务后update，导致死锁问题







### 分解关联查询

返回一个结果，直接set

返回多个结果，for循环匹配join条件



### idea快捷键

`ctrl + alt + t` 一键if、try-catch等



##### 







### 第三方库

##### 验证码

https://gitee.com/anji-plus/captcha

```xml
<dependency>
   <groupId>com.anji-plus</groupId>
   <artifactId>spring-boot-starter-captcha</artifactId>
   <version>1.3.0</version>
</dependency>
```



### 原生库

- Objects
- Arrays
- Streams
- Collections











### sql复杂功能实现

##### 行转列、列转行









### 集合类

##### RandomAccess接口

随机访问，标识作用，

实现后用for循环比用迭代器更快







### 思想

##### 映射

dns

##### 网关

分线器、nginx